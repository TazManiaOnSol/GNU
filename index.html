prompt: `Analyze this Solana wallet portfolio: ${currentWallet.toString()}
                
                <typescript-interface>
                interface Response {
                  analysis: string;
                  riskScore: number;
                  recommendation: string;
                }
                </typescript-interface>
                
                <example>
                {
                  "analysis": "Portfolio shows good diversification across DeFi protocols",
                  "riskScore": 7.5,
                  "recommendation": "Consider increasing stablecoin holdings"
                }
                </example>`
      })
    });
    const data = await response.json();
    document.getElementById('portfolioAnalysis').innerHTML = `
              <p>${data.analysis}</p>
              <p><strong>Risk Score:</strong> ${data.riskScore}/10</p>
              <p><strong>Recommendation:</strong> ${data.recommendation}</p>
            `;
  } catch (error) {
    console.error('Error updating portfolio analysis:', error);
  }
}
async function updateTokenBalances() {
  if (!currentWallet) return;
  try {
    const tokenAccounts = await connection.getParsedTokenAccountsByOwner(currentWallet, {
      programId: new solanaWeb3.PublicKey('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA')
    });
    const tokenBalancesHTML = tokenAccounts.value.map(account => `
              <div class="token-balance">
                <span>${account.account.data.parsed.info.mint.slice(0, 4)}...${account.account.data.parsed.info.mint.slice(-4)}</span>
                <span>${account.account.data.parsed.info.tokenAmount.uiAmount}</span>
              </div>
            `).join('');
    document.getElementById('tokenBalances').innerHTML = `
              <h3>Token Balances</h3>
              ${tokenBalancesHTML}
            `;
  } catch (error) {
    console.error('Error updating token balances:', error);
  }
}
async function updateTradeSuggestions() {
  try {
    const marketData = await fetch('https://api.coingecko.com/api/v3/coins/solana?localization=false&tickers=false&market_data=true&community_data=false&developer_data=false&sparkline=false').then(res => res.json());
    const suggestions = [];
    const priceChange24h = marketData.market_data.price_change_percentage_24h;
    const athChange = marketData.market_data.ath_change_percentage.usd;
    const volume = marketData.market_data.total_volume.usd;
    if (priceChange24h < -5) {
      suggestions.push({
        action: "Consider accumulating SOL",
        reason: `Price down ${priceChange24h.toFixed(2)}% in 24h - potential buying opportunity`,
        confidence: 75
      });
    }
    if (athChange < -30) {
      suggestions.push({
        action: "Long-term accumulation zone",
        reason: `Currently ${athChange.toFixed(2)}% below all-time high`,
        confidence: 85
      });
    }
    if (volume > 1000000000) {
      suggestions.push({
        action: "Monitor for breakout",
        reason: "High volume indicating strong market interest",
        confidence: 70
      });
    }
    document.getElementById('tradeSuggestions').innerHTML = suggestions.map(suggestion => `
      <div class="suggestion-item">
        <p><strong>${suggestion.action}</strong></p>
        <p>${suggestion.reason}</p>
        <p>Confidence: ${suggestion.confidence}%</p>
      </div>
    `).join('');
  } catch (error) {
    console.error('Error updating trade suggestions:', error);
    document.getElementById('tradeSuggestions').innerHTML = '<p>Error fetching trade suggestions</p>';
  }
}
const shownNewsIds = new Set();
async function generateCryptoNews() {
  try {
    const newsResponse = await fetch('https://min-api.cryptocompare.com/data/v2/news/?lang=EN&api_key=YOUR_API_KEY');
    const newsData = await newsResponse.json();
    const newArticles = newsData.Data.filter(article => !shownNewsIds.has(article.id));
    if (newArticles.length === 0) {
      shownNewsIds.clear();
      return generateCryptoNews();
    }
    const headlines = newArticles.slice(0, 3).map(article => {
      shownNewsIds.add(article.id);
      return {
        title: article.title,
        impact: article.sentiment === 'positive' ? 'positive' : article.sentiment === 'negative' ? 'negative' : 'neutral',
        details: article.body.slice(0, 100) + '...',
        url: article.url
      };
    });
    return headlines;
  } catch (error) {
    console.error('Error fetching crypto news:', error);
    return [];
  }
}
async function generateNFT() {
  const prompt = document.getElementById('nftPrompt').value.trim();
  const style = document.getElementById('nftStyle').value;
  if (!prompt) return;
  
  const preview = document.getElementById('nftPreview');
  const downloadBtn = document.getElementById('downloadNFT');
  const magicEdenBtn = document.getElementById('listMagicEden');
  
  preview.innerHTML = '<p>Generating NFT...</p>';
  downloadBtn.disabled = true;
  magicEdenBtn.disabled = true;

  try {
    const response = await fetch('/api/ai_completion', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json'
      },
      body: JSON.stringify({
        prompt: `Generate an NFT artwork in ${style} style based on this description: ${prompt}
        
        <typescript-interface>
        interface Response {
          svg: string;
          attributes: Array<{
            trait_type: string;
            value: string;
          }>;
        }
        </typescript-interface>

        <example>
        {
          "svg": "<svg width='400' height='400'>...</svg>",
          "attributes": [
            {
              "trait_type": "Style",
              "value": "Pixel Art"
            },
            {
              "trait_type": "Theme",
              "value": "Cyberpunk"
            }
          ]
        }
        </example>`,
        data: {
          prompt,
          style
        }
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();
    
    if (!data || !data.svg) {
      throw new Error('Invalid response format');
    }

    preview.innerHTML = data.svg;
    downloadBtn.disabled = false;
    magicEdenBtn.disabled = false;

    // Add to gallery
    const gallery = document.getElementById('nftGallery');
    const nftItem = document.createElement('div');
    nftItem.className = 'nft-item';
    nftItem.innerHTML = `
      ${data.svg}
      <p><strong>Style:</strong> ${style}</p>
      <p><strong>Traits:</strong></p>
      ${data.attributes?.map(attr => `<p>${attr.trait_type}: ${attr.value}</p>`).join('') || ''}
    `;
    gallery.prepend(nftItem);

  } catch (error) {
    console.error('Error generating NFT:', error);
    preview.innerHTML = `<p>Error generating NFT: ${error.message}</p>`;
    downloadBtn.disabled = true;
    magicEdenBtn.disabled = true;
  }
}
async function fetchCryptoGainers() {
  try {
    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=price_change_percentage_24h_desc&per_page=12&page=1&sparkline=false');
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('Error fetching crypto gainers:', error);
    return [];
  }
}
async function updateCryptoGainers() {
  const gainersContainer = document.getElementById('cryptoGainers');
  try {
    const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=price_change_percentage_24h_desc&per_page=12&page=1&sparkline=false', {
      cache: 'no-store'
    });
    const gainers = await response.json();
    gainersContainer.innerHTML = gainers.map(coin => `
      <div class="crypto-gainer-card" onclick="window.open('https://coinmarketcap.com/currencies/${coin.id}', '_blank')">
        <img src="${coin.image}" width="30" height="30" alt="${coin.name}">
        <h3>${coin.symbol.toUpperCase()}</h3>
        <div class="gainer-price">$${coin.current_price.toFixed(2)}</div>
        <div class="gainer-change ${coin.price_change_percentage_24h >= 0 ? 'positive' : 'negative'}">
          ${coin.price_change_percentage_24h.toFixed(2)}%
        </div>
      </div>
    `).join('');
  } catch (error) {
    gainersContainer.innerHTML = '<p>Error loading crypto gainers</p>';
    console.error('Error updating crypto gainers:', error);
  }
}
function downloadNFT() {
  const svg = document.getElementById('nftPreview').innerHTML;
  const blob = new Blob([svg], {
    type: 'image/svg+xml'
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'nft.svg';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
async function listOnMagicEden() {
  showDevelopmentNotification();
}
function showDevelopmentNotification() {
  let notification = document.getElementById('development-notification');
  if (!notification) {
    notification = document.createElement('div');
    notification.id = 'development-notification';
    document.body.appendChild(notification);
  }
  notification.innerHTML = `
    <h3 style="margin-bottom: 0.5rem"> Coming Soon!</h3>
    <p>Magic Eden integration is under development and will be ready in 2 days.</p>
  `;
  notification.style.display = 'block';
  setTimeout(() => {
    notification.style.display = 'none';
  }, 3000);
}
window.onload = async () => {
  await Promise.all([updateTerminal(), updateCryptoGainers()]).catch(console.error);
};
setInterval(async () => {
  if (document.getElementById('dashboard').classList.contains('active')) {
    await Promise.all([updateCryptoGainers(), updateTradeSuggestions()]).catch(console.error);
  }
}, 60000);
setInterval(async () => {
  if (document.getElementById('dashboard').classList.contains('active')) {
    await updateCryptoGainers().catch(console.error);
  }
}, 30000);
</script>
</body>
    </html>
